#include <iostream>
#include <math.h>
#include <cmath>
#include <string.h>


class myComplex {
private:
    double real;
    double imag;
public:
    myComplex();

    myComplex(double a);

    myComplex(double a, double b);

    myComplex(const myComplex &v);


    double getReal();  //返回复数的实部
    double getImaginary();  //返回复数的虚部
    double getModulus(); //返回复数的模

    void setReal(double r);  //设置复数的实部
    void setImaginary(double i);  //设置复数的虚部

    myComplex& operator=(const myComplex &rhs);  //类对象的赋值

    myComplex& operator+=(const myComplex &rhs);

    myComplex& operator-=(const myComplex &rhs);

    myComplex& operator*=(const myComplex &rhs);

    myComplex& operator/=(const myComplex &rhs);

    friend myComplex operator+(myComplex m, myComplex n);

    friend myComplex operator-(myComplex m, myComplex n);

    friend myComplex operator*(myComplex m, myComplex n);

    friend myComplex operator/(myComplex m, myComplex n);

    friend ostream& operator<<(ostream &os, myComplex &c);

    friend istream& operator>>(istream &is, myComplex &c);
};

myComplex::myComplex(){
	real = 0;
	imag = 0;
}

myComplex::myComplex(double a){
	real = a;
	imag = 0;
}

myComplex::myComplex(double a, double b){
	real = a;
	imag = b;
}

myComplex::myComplex(const myComplex &v){
	real = v.real;
	imag = v.imag;
}

double myComplex::getImaginary() {
    return this->imag;
}

double myComplex::getReal() {
    return this->real;
}

double myComplex::getModulus() {
    return sqrt(this->imag * this->imag + this->real * this->real);
}

void myComplex::setReal(double r) {
    this->real = r;
}

void myComplex::setImaginary(double i) {
    this->imag = i;
}

myComplex& myComplex::operator=(const myComplex &rhs) {
    this->real = rhs.real;
    this->imag = rhs.imag;
    return *this;
}

myComplex& myComplex::operator+=(const myComplex &rhs) {
    real = real+rhs.real;
    imag = imag+rhs.imag;
    return *this;
}

myComplex& myComplex::operator-=(const myComplex &rhs) {
    real = real-rhs.real;
    imag = imag-rhs.imag;
    return *this;
}

myComplex& myComplex::operator*=(const myComplex &rhs) {
	real = real*rhs.real;
    imag = imag*rhs.imag;
    return *this;
}

myComplex& myComplex::operator/=(const myComplex &rhs) {
    real = real/rhs.real;
    imag = imag/rhs.imag;
    return *this;
}

myComplex operator+(myComplex m, myComplex n) {
	return myComplex(m.real+n.real,m.imag+n.imag);
}

myComplex operator-(myComplex m, myComplex n) {
    return myComplex(m.real-n.real,m.imag-n.imag);
}

myComplex operator*(myComplex m, myComplex n) {
    return myComplex(m.real*n.real-m.imag*n.imag,m.real*n.imag+m.imag*n.real)real;
}

myComplex operator/(myComplex m, myComplex n) {
    return myComplex((m.real*n.real+m.imag*n.imag)/(n.real*n.real+n.imag*n.imag),(m.real*n.real-m.real*n.imag)/(n.real*n.real+n.imag*n.imag));
}

ostream &operator<<(ostream &os, myComplex &c) {
    os<<"("<<c,real<<"+"<<c.imag<<"i)"<<endl;
}

istream &operator>>(istream &is, myComplex &c) {
    is>>c.real>>c.imag;
    return is;
}

int main() {
    myComplex c1,c2,c3,c4;
    cout << "输入第一个复数: "<< endl;
    cin>>c1>>c2;
    myComplex m(c1,c2);
    cout << "输入第二个复数: "<< endl;
    cin>>c3>>c4;
    myComplex n(c3,c4);
    cout<<"m="<<m<<endl;
    cout<<"n="<<n<<endl;
    cout<<"m+n="<<m+n<<endl;
    cout<<"m-n="<<m-n<<endl;
    cout<<"m*n="<<m*n<<endl;
    cout<<"m/n="<<m/n<<endl;
    return 0;

}
